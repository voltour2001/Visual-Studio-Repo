<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Registration Toolkit: rt::rtMultiAccelerationStructure&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rticon_inv.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Registration Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacert.html">rt</a></li><li class="navelem"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rtMultiAccelerationStructure</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrt_1_1rt_multi_acceleration_structure-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rt::rtMultiAccelerationStructure&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ads_8h_source.html">ads.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rt::rtMultiAccelerationStructure&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrt_1_1rt_multi_acceleration_structure.png" usemap="#rt::rtMultiAccelerationStructure_3C_20T_20_3E_map" alt=""/>
  <map id="rt::rtMultiAccelerationStructure_3C_20T_20_3E_map" name="rt::rtMultiAccelerationStructure&lt; T &gt;_map">
<area href="classrt_1_1rt_acceleration_structure.html" alt="rt::rtAccelerationStructure&lt; T &gt;" shape="rect" coords="0,0,216,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a74276c79a2467b509d98ab1e73976b93"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classrt_1_1_a_siterator.html">ASiterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a74276c79a2467b509d98ab1e73976b93">iterator</a></td></tr>
<tr class="memdesc:a74276c79a2467b509d98ab1e73976b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rtAccelerator&lt;T&gt;::iterator type. Subclass in the derived AS.  <a href="#a74276c79a2467b509d98ab1e73976b93">More...</a><br /></td></tr>
<tr class="separator:a74276c79a2467b509d98ab1e73976b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8aa1ff0cf0efafe1d116f067406ab02c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#a8aa1ff0cf0efafe1d116f067406ab02c">build</a> ()</td></tr>
<tr class="separator:a8aa1ff0cf0efafe1d116f067406ab02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39147aa48465df8de07a3c5b2b71868"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#af39147aa48465df8de07a3c5b2b71868">addData</a> (T *data_ptr)</td></tr>
<tr class="separator:af39147aa48465df8de07a3c5b2b71868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0f27d5cf143e249234f2cd0e8994cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#aac0f27d5cf143e249234f2cd0e8994cb">setDistanceMetric</a> (std::function&lt; float(const T &amp;, const T &amp;)&gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html#ad5449aa3377282316745230f28b8258e">metric</a>)</td></tr>
<tr class="separator:aac0f27d5cf143e249234f2cd0e8994cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9426c2fc4aadfe42e0bbbe47848df931"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#a9426c2fc4aadfe42e0bbbe47848df931">nearest</a> (T *result, const T &amp;query) const </td></tr>
<tr class="separator:a9426c2fc4aadfe42e0bbbe47848df931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aadda4604cd7e672579b7a114983b02"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#a8aadda4604cd7e672579b7a114983b02">distanceToNearest</a> (const T &amp;query) const </td></tr>
<tr class="separator:a8aadda4604cd7e672579b7a114983b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15615a780bfc1537b7af2aa6c98bb2bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#a15615a780bfc1537b7af2aa6c98bb2bb">selectCurrentStructure</a> (int index)</td></tr>
<tr class="separator:a15615a780bfc1537b7af2aa6c98bb2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424b81ef315a1bc9a774014ef91a4b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#a424b81ef315a1bc9a774014ef91a4b7a">getCurrentStructure</a> ()</td></tr>
<tr class="separator:a424b81ef315a1bc9a774014ef91a4b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5961ccbb03a5b4ed2873147219bf2b3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_multi_acceleration_structure.html#a5961ccbb03a5b4ed2873147219bf2b3b">addStructure</a> (<a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a>&lt; T &gt; *as)</td></tr>
<tr class="separator:a5961ccbb03a5b4ed2873147219bf2b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e700204d3f7902cdfafe0aaf703a2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a08e700204d3f7902cdfafe0aaf703a2e">getCapability</a> (<a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> cap) const </td></tr>
<tr class="separator:a08e700204d3f7902cdfafe0aaf703a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2a120b705163742db31245ac14417f"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a2e2a120b705163742db31245ac14417f">getErrorMargin</a> ()</td></tr>
<tr class="separator:a2e2a120b705163742db31245ac14417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0b9d3d46bd08ff021e683c99ccfa8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a62c0b9d3d46bd08ff021e683c99ccfa8">size</a> ()</td></tr>
<tr class="separator:a62c0b9d3d46bd08ff021e683c99ccfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b7304f1776de77305497f54514d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ab49b7304f1776de77305497f54514d2a">getBoundsMin</a> (float *bbmin)</td></tr>
<tr class="separator:ab49b7304f1776de77305497f54514d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f720a9c9bc2e542f326072f7619052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a81f720a9c9bc2e542f326072f7619052">getBoundsMax</a> (float *bbmax)</td></tr>
<tr class="separator:a81f720a9c9bc2e542f326072f7619052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bafde672eea7c89daec7a9f61528e6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a3bafde672eea7c89daec7a9f61528e6f">addData</a> (T *data_ptr, unsigned long num)</td></tr>
<tr class="separator:a3bafde672eea7c89daec7a9f61528e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6bc8b2f860d4513bf5103fdaf2e3eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a7a6bc8b2f860d4513bf5103fdaf2e3eb">multiNearest</a> (T *result, T *query, unsigned int num) const </td></tr>
<tr class="separator:a7a6bc8b2f860d4513bf5103fdaf2e3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16683497078ff773425169dc208ed0d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a16683497078ff773425169dc208ed0d8">multiDistanceToNearest</a> (float *distance, T *query, unsigned long num) const </td></tr>
<tr class="separator:a16683497078ff773425169dc208ed0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acc2388bf7d3c186db0f2f1fa0d8244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1_a_siterator.html">ASiterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a8acc2388bf7d3c186db0f2f1fa0d8244">begin</a> () const </td></tr>
<tr class="separator:a8acc2388bf7d3c186db0f2f1fa0d8244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9383c002750b1d91d2723a422e0246"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1_a_siterator.html">ASiterator</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a3d9383c002750b1d91d2723a422e0246">end</a> () const </td></tr>
<tr class="separator:a3d9383c002750b1d91d2723a422e0246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b46dbb7cdf6c2edda6015f12c34416"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ab2b46dbb7cdf6c2edda6015f12c34416">clear</a> ()</td></tr>
<tr class="separator:ab2b46dbb7cdf6c2edda6015f12c34416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b26f83e3b86e7f39dfb8c9ab40308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#af61b26f83e3b86e7f39dfb8c9ab40308">isReady</a> ()</td></tr>
<tr class="separator:af61b26f83e3b86e7f39dfb8c9ab40308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7bf4b81408fe73d99b39b94ebdcbcde8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a7bf4b81408fe73d99b39b94ebdcbcde8">updateBounds</a> (const Eigen::Vector3f &amp;point)</td></tr>
<tr class="separator:a7bf4b81408fe73d99b39b94ebdcbcde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad5449aa3377282316745230f28b8258e"><td class="memItemLeft" align="right" valign="top">std::function&lt; float(const T &amp;, const T &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ad5449aa3377282316745230f28b8258e">metric</a></td></tr>
<tr class="memdesc:ad5449aa3377282316745230f28b8258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">member to hold the distance metric used on the particular template data T.  <a href="#ad5449aa3377282316745230f28b8258e">More...</a><br /></td></tr>
<tr class="separator:ad5449aa3377282316745230f28b8258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a9e53f6c727f36e6c39e94b42d5d8cb9a">ready</a> = false</td></tr>
<tr class="memdesc:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the data structure is initialized and ready to query.  <a href="#a9e53f6c727f36e6c39e94b42d5d8cb9a">More...</a><br /></td></tr>
<tr class="separator:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8aeacff50410161aab94447676c69f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a4e8aeacff50410161aab94447676c69f">_size</a></td></tr>
<tr class="memdesc:a4e8aeacff50410161aab94447676c69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal member holding the number of data elements (points);.  <a href="#a4e8aeacff50410161aab94447676c69f">More...</a><br /></td></tr>
<tr class="separator:a4e8aeacff50410161aab94447676c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cb179fba9d2636d71e57819af58c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a57cb179fba9d2636d71e57819af58c15">capabilities</a></td></tr>
<tr class="memdesc:a57cb179fba9d2636d71e57819af58c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary mask of the AS capabilities.  <a href="#a57cb179fba9d2636d71e57819af58c15">More...</a><br /></td></tr>
<tr class="separator:a57cb179fba9d2636d71e57819af58c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415cead4f56b55e5af0fab4299cdb90d"><td class="memItemLeft" align="right" valign="top">Eigen::AlignedBox3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a415cead4f56b55e5af0fab4299cdb90d">bbox</a></td></tr>
<tr class="memdesc:a415cead4f56b55e5af0fab4299cdb90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding box of the contained data. The box is oriented according to the local coordinate system (OBB).  <a href="#a415cead4f56b55e5af0fab4299cdb90d">More...</a><br /></td></tr>
<tr class="separator:a415cead4f56b55e5af0fab4299cdb90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a74276c79a2467b509d98ab1e73976b93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classrt_1_1_a_siterator.html">ASiterator</a>&lt;T&gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::<a class="el" href="classrt_1_1rt_acceleration_structure.html#a74276c79a2467b509d98ab1e73976b93">iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rtAccelerator&lt;T&gt;::iterator type. Subclass in the derived AS. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a555fe621b433bd314f70cb6640bd3443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">rt::rtAccelerationStructure::capability_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a443f4ecd765758f6a39f074b2fea69dd"></a>RT_IS_APPROXIMATE&#160;</td><td class="fielddoc">
<p>Capability flag to check whether the AS returns approximate distances to nearest elements. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a932066457619dc95342dd3a40c415b27"></a>RT_SUPPORTS_NEAREST_QUERIES&#160;</td><td class="fielddoc">
<p>Capability frag to check if the AS supports nearest element queries. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a0fdd2b88296364ee7114d0cfe0d414f4"></a>RT_IS_ITERABLE&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3bafde672eea7c89daec7a9f61528e6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::addData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a number num of elements of type T to the data structure.</p>
<p>The method can be called multiple times to inject more data to the acceleration structure. Each time the addData method is called, the ready flag must be set to false if the AS needs to be rebuilt (ususally it has to).</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, an error code with a brief explanation in the message field, otherwise. Typically, RT_INVALID_OPERATION must be returned if the structure is already initialized, and RT_INTERNAL_ERROR if something went wrong. No other return codes are applicable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_ptr</td><td>is a pointer to a preallocated array of elements of type T to be inserted in the AS. </td></tr>
    <tr><td class="paramname">num</td><td>defines the number of elements in the data_ptr array to read. Caution must be excercised to correctly specify the number of elements to read from the array, as there is no way to check its bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrt_1_1rt_distance_field.html#a89e6044df0b5e6efd95795c456dc8104">rt::rtDistanceField&lt; T &gt;</a>, <a class="el" href="classrt_1_1rt_h_grid.html#abd38e253092a592d4cf85282e6a5fa71">rt::rtHGrid&lt; T &gt;</a>, and <a class="el" href="classrt_1_1rt_soup.html#abe17c49130779f2c4f5bcfffba88adce">rt::rtSoup&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af39147aa48465df8de07a3c5b2b71868"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::addData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5961ccbb03a5b4ed2873147219bf2b3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::addStructure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>as</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8acc2388bf7d3c186db0f2f1fa0d8244"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1_a_siterator.html">ASiterator</a>&lt; T &gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a forward input iterator to the internal acceleration structure data at the begin of the internal collection implemented.</p>
<dl class="section return"><dt>Returns</dt><dd>the iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a8aa1ff0cf0efafe1d116f067406ab02c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs and / or finalizes internal data structures that hold the geometry data to be queried.</p>
<p>Derived classes must implement this method. The member function must set the ready member to true, if the initialization process was successful. </p><dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, an error code with a brief explanation in the message field, otherwise. Typically, RT_INVALID_OPERATION must be returned if the structure is already initialized, and RT_INTERNAL_ERROR if something went wrong. No other return codes are applicable. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab2b46dbb7cdf6c2edda6015f12c34416"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans up the data stored in the acceleration structure. </p>

<p>Reimplemented in <a class="el" href="classrt_1_1rt_distance_field.html#a3a5476243acfbe59152d64e4da09b2f2">rt::rtDistanceField&lt; T &gt;</a>, <a class="el" href="classrt_1_1rt_h_grid.html#acf0c79cca3e17ff15c516b2a94a23087">rt::rtHGrid&lt; T &gt;</a>, and <a class="el" href="classrt_1_1rt_soup.html#ae13d514293af0a332ac967f2c681223f">rt::rtSoup&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8aadda4604cd7e672579b7a114983b02"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::distanceToNearest </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance to the nearest element to the query input. All acceleration structures must override this method.</p>
<p>The method searches and returns the distance to the closest element to the query according to the distance metric provided in the AS. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>is the input query object of type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance to the nearest object in the AS, or FLT_MAX if the AS is empty or uninitialized. The return value is allowed to be a negative value, as particular acceleration structures may report negative (oriented) distances. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#af40b44b18aaa62c23af48a9578e8875e">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3d9383c002750b1d91d2723a422e0246"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1_a_siterator.html">ASiterator</a>&lt; T &gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a forward input iterator to the internal acceleration structure data at the end of the internal collection implemented (out of range).</p>
<dl class="section return"><dt>Returns</dt><dd>an out-of-range iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a81f720a9c9bc2e542f326072f7619052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getBoundsMax </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bbmax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns in the parameter bbmax the three float coordinates of the maximum corner of the bounding box of the spatial data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbmax</td><td>is the pointer to a pre-allocated array that the three coordinates of the cbounding box corner are copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, or RT_INVALID_PARAMS if bbmax is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ab49b7304f1776de77305497f54514d2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getBoundsMin </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bbmin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns in the parameter bbmin the three float coordinates of the minimum corner of the bounding box of the spatial data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbmin</td><td>is the pointer to a pre-allocated array that the three coordinates of the cbounding box corner are copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, or RT_INVALID_PARAMS if bbmin is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a08e700204d3f7902cdfafe0aaf703a2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries if the acceleration structure provides a certain capability.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the AS has the specified capability. </dd></dl>

</div>
</div>
<a class="anchor" id="a424b81ef315a1bc9a774014ef91a4b7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a>&lt;T&gt;* <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::getCurrentStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e2a120b705163742db31245ac14417f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getErrorMargin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum error introduced by the spatial acceleration structure. This is zero for a non-approximate AS.</p>
<dl class="section return"><dt>Returns</dt><dd>0.0f if the AS is not approximate, otherwise the maximum (estimated) point-to-AS distance error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isApproximate. </dd></dl>

<p>Reimplemented in <a class="el" href="classrt_1_1rt_distance_field.html#a162639c87cd118f910b17713a8014742">rt::rtDistanceField&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af61b26f83e3b86e7f39dfb8c9ab40308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries whether the AS is ready for searching. Normally, this is true after calling <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">build()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the AS is initialized, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a16683497078ff773425169dc208ed0d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::multiDistanceToNearest </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance to the nearest element to the query input. It is the multiple input version of the <a class="el" href="classrt_1_1rt_acceleration_structure.html#af40b44b18aaa62c23af48a9578e8875e">distanceToNearest()</a> method.</p>
<p>The method searches and returns the distance of all query points to their respective closest element, according to the distance metric provided in the AS. The distance function provided may or may not use the entire set of coordinates. Whenever possible, use this function instead of the simple <a class="el" href="classrt_1_1rt_acceleration_structure.html#af40b44b18aaa62c23af48a9578e8875e">distanceToNearest()</a> method, as it favors efficient and parallel queries, depending on implementation. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to an array variable to contain the query results, if the operation is supported. The result array must be pre-allocated with sufficient space to hold num returned elements. </td></tr>
    <tr><td class="paramname">query</td><td>is an array of input elements of type T for which the closest elements are returned, if the operation is supported. </td></tr>
    <tr><td class="paramname">num</td><td>is the number of points to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented in <a class="el" href="classrt_1_1rt_distance_field.html#aa48b3c1f83720e30c879e4901e549658">rt::rtDistanceField&lt; T &gt;</a>, <a class="el" href="classrt_1_1rt_h_grid.html#ae6e9447cfdaef1cd13c76e0eaa115b98">rt::rtHGrid&lt; T &gt;</a>, and <a class="el" href="classrt_1_1rt_soup.html#aac03d7959517dd6d3f026aeb33378780">rt::rtSoup&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7a6bc8b2f860d4513bf5103fdaf2e3eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::multiNearest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest elements corresponding to the query points. It is the multiple input version of the <a class="el" href="classrt_1_1rt_acceleration_structure.html#a09aab0d67005fa726a092d72d2a8124e">nearest()</a> method.</p>
<p>The method searches and returns the closest elements to the query array of points according to the distance metric provided in the AS. Whenever possible, use this function instead of the simple <a class="el" href="classrt_1_1rt_acceleration_structure.html#a09aab0d67005fa726a092d72d2a8124e">nearest()</a> method, as it favors efficient and parallel queries, depending on implementation. If the method does not support the operation, the code retutned in the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is set to RT_INVALID _OPERATION. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to an array variable to contain the query results, if the operation is supported. The result array must be pre-allocated with sufficient space to hold num returned elements. </td></tr>
    <tr><td class="paramname">query</td><td>is an array of input elements of type T for which the closest elements are returned, if the operation is supported. </td></tr>
    <tr><td class="paramname">num</td><td>is the number of points to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented in <a class="el" href="classrt_1_1rt_distance_field.html#adf5a7891ab37a761f6dff28b7f03b577">rt::rtDistanceField&lt; T &gt;</a>, <a class="el" href="classrt_1_1rt_h_grid.html#ad4a3f39a30388136f116325e073859f2">rt::rtHGrid&lt; T &gt;</a>, and <a class="el" href="classrt_1_1rt_soup.html#a7f541a73c15f626ea0c9a53c9b773726">rt::rtSoup&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9426c2fc4aadfe42e0bbbe47848df931"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::nearest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest element to the query input located in the data structure. This is an optional operation.</p>
<p>The method searches and returns the closest element to the query according to the distance metric provided in the AS. If the method does not support the operation, the code retutned in the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is set to RT_INVALID _OPERATION. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to a variable to contain the query result, if the operation is supported. </td></tr>
    <tr><td class="paramname">query</td><td>is the input query object of type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a09aab0d67005fa726a092d72d2a8124e">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a15615a780bfc1537b7af2aa6c98bb2bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::selectCurrentStructure </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac0f27d5cf143e249234f2cd0e8994cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T  = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classrt_1_1rt_multi_acceleration_structure.html">rt::rtMultiAccelerationStructure</a>&lt; T &gt;::setDistanceMetric </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float(const T &amp;, const T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a62c0b9d3d46bd08ff021e683c99ccfa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of countable elements in the structure. Please note that this number may be not very descriptive for certain types of acceleration structure (e.g. distance fields).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of discrete elements in the AS. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bf4b81408fe73d99b39b94ebdcbcde8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::updateBounds </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4e8aeacff50410161aab94447676c69f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal member holding the number of data elements (points);. </p>

</div>
</div>
<a class="anchor" id="a415cead4f56b55e5af0fab4299cdb90d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::AlignedBox3f <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::bbox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounding box of the contained data. The box is oriented according to the local coordinate system (OBB). </p>

</div>
</div>
<a class="anchor" id="a57cb179fba9d2636d71e57819af58c15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::capabilities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The binary mask of the AS capabilities. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5449aa3377282316745230f28b8258e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;float(const T &amp;, const T &amp;)&gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::metric</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>member to hold the distance metric used on the particular template data T. </p>

</div>
</div>
<a class="anchor" id="a9e53f6c727f36e6c39e94b42d5d8cb9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::ready = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if the data structure is initialized and ready to query. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/RT/<a class="el" href="ads_8h_source.html">ads.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
