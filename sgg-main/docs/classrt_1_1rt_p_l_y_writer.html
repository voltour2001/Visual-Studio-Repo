<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Registration Toolkit: rt::rtPLYWriter&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rticon_inv.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Registration Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacert.html">rt</a></li><li class="navelem"><a class="el" href="classrt_1_1rt_p_l_y_writer.html">rtPLYWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrt_1_1rt_p_l_y_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rt::rtPLYWriter&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="io_8h_source.html">io.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rt::rtPLYWriter&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrt_1_1rt_p_l_y_writer.png" usemap="#rt::rtPLYWriter_3C_20T_20_3E_map" alt=""/>
  <map id="rt::rtPLYWriter_3C_20T_20_3E_map" name="rt::rtPLYWriter&lt; T &gt;_map">
<area href="classrt_1_1rt_writer.html" alt="rt::rtWriter&lt; T &gt;" shape="rect" coords="0,56,137,80"/>
<area href="classrt_1_1rt_attribute_map.html" alt="rt::rtAttributeMap&lt; T &gt;" shape="rect" coords="0,0,137,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe3546ff46eeee62d9627c423759638c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_writer.html#afe3546ff46eeee62d9627c423759638c">writePointCloud</a> (std::string filename, T *data, long num_vertices)</td></tr>
<tr class="separator:afe3546ff46eeee62d9627c423759638c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae674796da9e0d3f05d9ece4809da4d87"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_writer.html#ae674796da9e0d3f05d9ece4809da4d87">writeMesh</a> (std::string filename, T *data, long num_vertices, long *indices=nullptr, long num_triangles=0)</td></tr>
<tr class="separator:ae674796da9e0d3f05d9ece4809da4d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e47e2a358d19b2b8f52dbc9d39ad1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset</a> (int attrib, int <a class="el" href="classrt_1_1rt_attribute_map.html#ae5921f5cc265c14a09298b5416e4d6c3">offset</a>)</td></tr>
<tr class="separator:aa4e47e2a358d19b2b8f52dbc9d39ad1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbe15066b4584842f2cf34a45ceee70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a1bbe15066b4584842f2cf34a45ceee70">getAttributeOffset</a> (int attrib, int *<a class="el" href="classrt_1_1rt_attribute_map.html#ae5921f5cc265c14a09298b5416e4d6c3">offset</a>)</td></tr>
<tr class="separator:a1bbe15066b4584842f2cf34a45ceee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995b503fc21f3471cdbd04c2c18b928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes</a> (int active_attribs)</td></tr>
<tr class="separator:a8995b503fc21f3471cdbd04c2c18b928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699b59a318c93b11f3546cda476626f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a3699b59a318c93b11f3546cda476626f">getActiveAttributes</a> ()</td></tr>
<tr class="separator:a3699b59a318c93b11f3546cda476626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a93344e83330dc2979fcdadd1a3cdc231"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_writer.html#a93344e83330dc2979fcdadd1a3cdc231">appendExtension</a> (std::string filename)</td></tr>
<tr class="separator:a93344e83330dc2979fcdadd1a3cdc231"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad91d5f1b04414fdd7fb888a0d8b07e7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad91d5f1b04414fdd7fb888a0d8b07e7d"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_writer.html#ad91d5f1b04414fdd7fb888a0d8b07e7d">extension</a></td></tr>
<tr class="memdesc:ad91d5f1b04414fdd7fb888a0d8b07e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native extension string of the file format. For example "ply" for the PLY format. It must be given in lower-case characters. <br /></td></tr>
<tr class="separator:ad91d5f1b04414fdd7fb888a0d8b07e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fa0a74383da0e38b63496e221ec2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34fa0a74383da0e38b63496e221ec2f1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a34fa0a74383da0e38b63496e221ec2f1">attribs</a></td></tr>
<tr class="memdesc:a34fa0a74383da0e38b63496e221ec2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mask of the active vertex attributes to export. If no other attribute is specified, the attribs mask equals RT_ATTRIB_POSITION. <br /></td></tr>
<tr class="separator:a34fa0a74383da0e38b63496e221ec2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5921f5cc265c14a09298b5416e4d6c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5921f5cc265c14a09298b5416e4d6c3"></a>
std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#ae5921f5cc265c14a09298b5416e4d6c3">offset</a></td></tr>
<tr class="memdesc:ae5921f5cc265c14a09298b5416e4d6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the offset with respect to the base pointer to a structure T (as the map entry value) of the attribute specified in the key argument. <br /></td></tr>
<tr class="separator:ae5921f5cc265c14a09298b5416e4d6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class rt::rtPLYWriter&lt; T &gt;</h3>

<p>A PLY format writer class for exporting point clouds and mesh data to a file.</p>
<p>The functionality is generic enough to support arbitrary vertex data of type T, whose attributes are enabled or disabled for export via a mask (see <a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes()</a> method) and whose specific offsets in the structure are made known to the writer via the <a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset()</a> method. The class supports two export methods, the <a class="el" href="classrt_1_1rt_p_l_y_writer.html#afe3546ff46eeee62d9627c423759638c">writePointCloud()</a> for exporting vertex data only and the <a class="el" href="classrt_1_1rt_p_l_y_writer.html#ae674796da9e0d3f05d9ece4809da4d87">writeMesh()</a> to export triangulated data with or without indexing.</p>
<p>Below is an example of using the PLYWriter to export a point cloud with vertex colors: </p><div class="fragment"><div class="line"></div><div class="line"><span class="comment">// Create a small  x, y, z, r, g, b point cloud by scan converting a triangle</span></div><div class="line">std::array&lt;float, 6&gt; triangle[3] = { { -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f }, </div><div class="line">                                     { 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f }, </div><div class="line">                                     { 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f } };</div><div class="line"></div><div class="line"><span class="comment">// Set up the rasterizer:</span></div><div class="line">rt::rtScanConverter&lt;std::array&lt;float, 6&gt;&gt; rasterizer;</div><div class="line">rasterizer.setStride(0.2f);</div><div class="line">rasterizer.setNumAttribCoefs(3);</div><div class="line">rasterizer.useAttributeInterpolation(<span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Create a vector to host the samples and perform the scan conversion:</span></div><div class="line">std::vector&lt;std::array&lt;float, 6&gt;&gt; samples;</div><div class="line">rasterizer.convertTriangle(samples, triangle);</div><div class="line"></div><div class="line"><span class="comment">// Initialize a PLY format writer to work on std::array&lt;float, 6&gt; data </span></div><div class="line"><span class="comment">// and export both vertex positions and vertex colors</span></div><div class="line"><a class="code" href="classrt_1_1rt_p_l_y_writer.html">rt::rtPLYWriter&lt;std::array&lt;float, 6&gt;</a>&gt; writer(rt::attribute_t::RT_ATTRIB_POSITION | rt::attribute_t::RT_ATTRIB_COLOR);</div><div class="line"></div><div class="line"><span class="comment">// Notify the writer where to find the color attribute values, </span></div><div class="line"><span class="comment">// by passing the offset realteive to the base of the </span></div><div class="line"><span class="comment">// std::array&lt;float, 6&gt; structure</span></div><div class="line"><a class="code" href="classrt_1_1rt_result.html">rt::rtResult</a> res =  writer.setAttributeOffset(rt::attribute_t::RT_ATTRIB_COLOR, 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line"></div><div class="line"><span class="comment">// Perform the write operation</span></div><div class="line"><span class="keywordflow">if</span> (res.<a class="code" href="classrt_1_1rt_result.html#aa9364f7171b2c84560554e99f6d5f97f">code</a> == <a class="code" href="classrt_1_1rt_result.html#ae245a76410afe70c07165f998bca9464ad243e4b3c95d5e815186b8acc8c3ca0d">rt::rtResult::RT_OK</a>)</div><div class="line">{</div><div class="line">    res = writer.writePointCloud(<span class="stringliteral">&quot;triangle.ply&quot;</span>, &amp;(samples[0]), samples.size());</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Report any errors</span></div><div class="line">std::cout &lt;&lt; res.<a class="code" href="classrt_1_1rt_result.html#a2dd6436e4fba08b0cc9b0c8fbc542629">message</a>;</div></div><!-- fragment --> <dl><dt><b>Examples: </b></dt><dd><a class="el" href="_example-_p_l_y_writer_8cpp-example.html#_a0">Example-PLYWriter.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a93344e83330dc2979fcdadd1a3cdc231"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classrt_1_1rt_writer.html">rt::rtWriter</a>&lt; T &gt;::appendExtension </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to detect if a provided filename has the proper extension. If not, the extension is attached to the filename argument. The resulting string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>is the (input) filename to check for a proper extension.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the correct string ending with the file format extension. If the filename string already contains the appropriate file extension the returned string equals the filename input parameter. Otherwise, the default extension of the particular writer is appended to the filename parameter (with a '.' character between the filename and the suffix) and the resulting string is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a3699b59a318c93b11f3546cda476626f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::getActiveAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the mask of enabled attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the attribute mask.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bbe15066b4584842f2cf34a45ceee70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::getAttributeOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the designated offset in the vertex data structure of the named attribute attrib, in bytes.</p>
<p>All attributes are considered float numbers. Vertex attributes are 3 consecutive float numbers (x,y,z), colour attributes are a float triplet representing the 3 colour component (r,g,b), the normal attribute expects 3 consecutive floats (the normal vector coordinates) and finally, the texture parameters are two floats corresponding to the two (u,v or s,t) texture parameters on the surface of the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td>should be one of RT_ATTRIB_POSITION, RT_ATTRIB_NORMAL, RT_ATTRIB_COLOR or RT_ATTRIB_TEXCOORD and signifies the offset definition for vertex, normal, color or texture coordinate attributes respectively. </td></tr>
    <tr><td class="paramname">offset</td><td>is the returned distance in bytes from the beginning of the data structure T that the corresponding attrib values begin at. If the attrib parameter is valid, the offset parameter is filled with the corresponding value. If the attribute identifier is out of range or no offset has been assigned to it, no value is written to offset and an error code is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure, whose code is RT_OK if the attribute was valid and its offset was set. Ifthe attribute did not match the enabled attributes, the return code is set to RT_INVALID_PARAMS. If the attribute offset was not set, an RT_FAILURE code is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8995b503fc21f3471cdbd04c2c18b928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::setActiveAttributes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active_attribs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the mask of attributes to enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active_attribs</td><td>is a binary mask of enabled attributes formed by the OR of the desired attribute_t flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure, whose code is RT_OK if the mask was correct or RT_INVALID_PARAMS, otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa4e47e2a358d19b2b8f52dbc9d39ad1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::setAttributeOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the offset in the vertex data structure of the named attribute attrib, in bytes.</p>
<p>All attributes are considered float numbers. Vertex attributes are 3 consecutive float numbers (x,y,z), colour attributes are a float triplet representing the 3 colour component (r,g,b), the normal attribute expects 3 consecutive floats (the normal vector coordinates) and finally, the texture parameters are two floats corresponding to the two (u,v or s,t) texture parameters on the surface of the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td>should be one of RT_ATTRIB_POSITION, RT_ATTRIB_NORMAL, RT_ATTRIB_COLOR or RT_ATTRIB_TEXCOORD and signifies the offset definition for vertex, normal, color or texture coordinate attributes respectively. </td></tr>
    <tr><td class="paramname">offset</td><td>is the distance in bytes from the beginning of the data structure T that the corresponding attrib values begin at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure, whose code is RT_OK if the offset for the specific attribute was successfully set or RT_INVALID_PARAMS if the attribute for which the offset was passed is not active or the offset is too large.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#a1bbe15066b4584842f2cf34a45ceee70">getAttributeOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae674796da9e0d3f05d9ece4809da4d87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_writer.html">rt::rtPLYWriter</a>&lt; T &gt;::writeMesh </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>indices</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_triangles</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes data as a mesh to a file provided in the filename parameter.</p>
<p>The point data of type T can be an arbitrary structure. The only requirement is that the indivudual vertex attribute coordinates are consecutive float numbers. The exact offset of each attribute tupple is provided by the settAttributeOffset() method. The triangular structure of the mesh is given as a list of triangle vertex indices (zero-based) in the indices parameter. If the indices buffer is NULL, no indexing is assumed, in which case the input vertices are considered in triplets to create the output triangles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>is the file name of the exported mesh. If the filename string's lowercase extension does not match the predetermined suffix of the specific format, the correct suffix is appended. </td></tr>
    <tr><td class="paramname">data</td><td>is a buffer of type T vertex structures. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>specifies the number of vertices in the buffer data. </td></tr>
    <tr><td class="paramname">indices</td><td>is a buffer of zero-based indices to the vertex buffer points. If it is equal to 0, input points are considered in triplets and num_vertices/3 triangles are formed in the output file. In this case, the num_triangles parameter is ignorred. </td></tr>
    <tr><td class="paramname">num_triangles</td><td>is used to determine the number of index triangles in the mesh in the case the indexing is provided explicitly through the parameter indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure containing the exit code of the member function. On successful write, a result with RT_OK is returned. If the method is not supported, an RT_INVALID_OPERATION is returned. Last, if the file cannot be opened for writing, the return code of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is RT_FAILURE. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_writer.html#a9d4c6e22753ec828f2a3c1d0742dc69c">rt::rtWriter&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afe3546ff46eeee62d9627c423759638c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_writer.html">rt::rtPLYWriter</a>&lt; T &gt;::writePointCloud </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes a point cloud to a file provided in the filename parameter.</p>
<p>The point data of type T can be an arbitrary structure. The only requirement is that the individual vertex attribute coordinates are consecutive float numbers. The exact offset of each attribute tupple is provided by the settAttributeOffset() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>is the file name of the exported point cloud. If the filename string's lowercase extension does not match the predetermined suffix of the specific format, the correct suffix is appended. </td></tr>
    <tr><td class="paramname">data</td><td>is a buffer of type T vertex structures. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>specifies the number of vertices in the buffer data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure containing the exit code of the member function. On successful write, a result with RT_OK is returned. If the method is not supported, an RT_INVALID_OPERATION is returned. Last, if the file cannot be opened for writing, the return code of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is RT_FAILURE. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_writer.html#af0f5680c16b80de9755c642dd828fa96">rt::rtWriter&lt; T &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/RT/<a class="el" href="io_8h_source.html">io.h</a></li>
<li>include/RT/<a class="el" href="io__ply_8hpp_source.html">io_ply.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
