<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Registration Toolkit: rt::rtSoup&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rticon_inv.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Registration Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacert.html">rt</a></li><li class="navelem"><a class="el" href="classrt_1_1rt_soup.html">rtSoup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrt_1_1rt_soup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rt::rtSoup&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="soup_8h_source.html">soup.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rt::rtSoup&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrt_1_1rt_soup.png" usemap="#rt::rtSoup_3C_20T_20_3E_map" alt=""/>
  <map id="rt::rtSoup_3C_20T_20_3E_map" name="rt::rtSoup&lt; T &gt;_map">
<area href="classrt_1_1rt_acceleration_structure.html" alt="rt::rtAccelerationStructure&lt; T &gt;" shape="rect" coords="0,0,189,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30654f474a7643c355136e311d7e35d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a30654f474a7643c355136e311d7e35d0">build</a> ()</td></tr>
<tr class="separator:a30654f474a7643c355136e311d7e35d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe17c49130779f2c4f5bcfffba88adce"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#abe17c49130779f2c4f5bcfffba88adce">addData</a> (T *data_ptr, unsigned long num)</td></tr>
<tr class="separator:abe17c49130779f2c4f5bcfffba88adce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b29dadbc41ba928ba5afaf6d575013d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a8b29dadbc41ba928ba5afaf6d575013d">nearest</a> (T *result, const T &amp;query) const </td></tr>
<tr class="separator:a8b29dadbc41ba928ba5afaf6d575013d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c83c06fbd18f6fae8f6a39c4b882c"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#af62c83c06fbd18f6fae8f6a39c4b882c">distanceToNearest</a> (const T &amp;query) const </td></tr>
<tr class="separator:af62c83c06fbd18f6fae8f6a39c4b882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f541a73c15f626ea0c9a53c9b773726"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a7f541a73c15f626ea0c9a53c9b773726">multiNearest</a> (T *result, T *query, unsigned int num) const </td></tr>
<tr class="separator:a7f541a73c15f626ea0c9a53c9b773726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac03d7959517dd6d3f026aeb33378780"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#aac03d7959517dd6d3f026aeb33378780">multiDistanceToNearest</a> (float *distance, T *query, unsigned long num) const </td></tr>
<tr class="separator:aac03d7959517dd6d3f026aeb33378780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb2d7b404d54fa3a4f512eaa5d905d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_iterator_soup.html">rtIteratorSoup</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a0feb2d7b404d54fa3a4f512eaa5d905d">begin</a> () const </td></tr>
<tr class="separator:a0feb2d7b404d54fa3a4f512eaa5d905d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cbc7fb1506cf8797ddd0f91adc6239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_iterator_soup.html">rtIteratorSoup</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a69cbc7fb1506cf8797ddd0f91adc6239">end</a> () const </td></tr>
<tr class="separator:a69cbc7fb1506cf8797ddd0f91adc6239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13d514293af0a332ac967f2c681223f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#ae13d514293af0a332ac967f2c681223f">clear</a> ()</td></tr>
<tr class="separator:ae13d514293af0a332ac967f2c681223f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd15ccc008d70450d3d36e9f2316e79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a7bd15ccc008d70450d3d36e9f2316e79">rtSoup</a> ()</td></tr>
<tr class="separator:a7bd15ccc008d70450d3d36e9f2316e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb46f751f84ef250d85c1416fd0f82b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#a7eb46f751f84ef250d85c1416fd0f82b">rtSoup</a> (bool noThreadedExecution)</td></tr>
<tr class="separator:a7eb46f751f84ef250d85c1416fd0f82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2287c98cf3defb64577438f869b2277"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#ac2287c98cf3defb64577438f869b2277">~rtSoup</a> ()</td></tr>
<tr class="separator:ac2287c98cf3defb64577438f869b2277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e700204d3f7902cdfafe0aaf703a2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a08e700204d3f7902cdfafe0aaf703a2e">getCapability</a> (<a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> cap) const </td></tr>
<tr class="separator:a08e700204d3f7902cdfafe0aaf703a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2a120b705163742db31245ac14417f"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a2e2a120b705163742db31245ac14417f">getErrorMargin</a> ()</td></tr>
<tr class="separator:a2e2a120b705163742db31245ac14417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0b9d3d46bd08ff021e683c99ccfa8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a62c0b9d3d46bd08ff021e683c99ccfa8">size</a> ()</td></tr>
<tr class="separator:a62c0b9d3d46bd08ff021e683c99ccfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b7304f1776de77305497f54514d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ab49b7304f1776de77305497f54514d2a">getBoundsMin</a> (float *bbmin)</td></tr>
<tr class="separator:ab49b7304f1776de77305497f54514d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f720a9c9bc2e542f326072f7619052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a81f720a9c9bc2e542f326072f7619052">getBoundsMax</a> (float *bbmax)</td></tr>
<tr class="separator:a81f720a9c9bc2e542f326072f7619052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73b08f81da3844638af4bb847e4a66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ad73b08f81da3844638af4bb847e4a66d">setDistanceMetric</a> (std::function&lt; float(const T &amp;, const T &amp;)&gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html#ad5449aa3377282316745230f28b8258e">metric</a>)</td></tr>
<tr class="separator:ad73b08f81da3844638af4bb847e4a66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b26f83e3b86e7f39dfb8c9ab40308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#af61b26f83e3b86e7f39dfb8c9ab40308">isReady</a> ()</td></tr>
<tr class="separator:af61b26f83e3b86e7f39dfb8c9ab40308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:addbda1bfde13610a008041c12aea6540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addbda1bfde13610a008041c12aea6540"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#addbda1bfde13610a008041c12aea6540">points</a></td></tr>
<tr class="memdesc:addbda1bfde13610a008041c12aea6540"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector containing the inserted elements. <br /></td></tr>
<tr class="separator:addbda1bfde13610a008041c12aea6540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c96428205cabc0b26105150cb3f870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6c96428205cabc0b26105150cb3f870"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_soup.html#aa6c96428205cabc0b26105150cb3f870">disableThreadedExecution</a></td></tr>
<tr class="memdesc:aa6c96428205cabc0b26105150cb3f870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the multiXX quieries to run sequentially. This is only used for the benchmarking of other AS. <br /></td></tr>
<tr class="separator:aa6c96428205cabc0b26105150cb3f870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5449aa3377282316745230f28b8258e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5449aa3377282316745230f28b8258e"></a>
std::function&lt; float(const T &amp;, const T &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ad5449aa3377282316745230f28b8258e">metric</a></td></tr>
<tr class="memdesc:ad5449aa3377282316745230f28b8258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">member to hold the distance metric used on the particular template data T. <br /></td></tr>
<tr class="separator:ad5449aa3377282316745230f28b8258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e53f6c727f36e6c39e94b42d5d8cb9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a9e53f6c727f36e6c39e94b42d5d8cb9a">ready</a> = false</td></tr>
<tr class="memdesc:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the data structure is initialized and ready to query. <br /></td></tr>
<tr class="separator:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8aeacff50410161aab94447676c69f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e8aeacff50410161aab94447676c69f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a4e8aeacff50410161aab94447676c69f">_size</a></td></tr>
<tr class="memdesc:a4e8aeacff50410161aab94447676c69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal member holding the number of data elements (points);. <br /></td></tr>
<tr class="separator:a4e8aeacff50410161aab94447676c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cb179fba9d2636d71e57819af58c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a57cb179fba9d2636d71e57819af58c15">capabilities</a></td></tr>
<tr class="memdesc:a57cb179fba9d2636d71e57819af58c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary mask of the AS capabilities.  <a href="#a57cb179fba9d2636d71e57819af58c15">More...</a><br /></td></tr>
<tr class="separator:a57cb179fba9d2636d71e57819af58c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415cead4f56b55e5af0fab4299cdb90d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a415cead4f56b55e5af0fab4299cdb90d"></a>
Eigen::AlignedBox3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a415cead4f56b55e5af0fab4299cdb90d">bbox</a></td></tr>
<tr class="memdesc:a415cead4f56b55e5af0fab4299cdb90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding box of the contained data. The box is oriented according to the local coordinate system (OBB). <br /></td></tr>
<tr class="separator:a415cead4f56b55e5af0fab4299cdb90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class rt::rtSoup&lt; T &gt;</h3>

<p>Simple flat (i.e. slow) acceleration structure intended as a working <a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a> subclass example and not as a performance AS.</p>
<p>Internally, <a class="el" href="classrt_1_1rt_soup.html">rtSoup</a> is implemented with an std::vector&lt;T&gt; and all searches are linear. As an exercise, one could easily implement a parallel version using the asynchronous theads of C++11 to perform reduction. The AS is also read-only forward-iterable using the <a class="el" href="classrt_1_1rt_soup.html#a0feb2d7b404d54fa3a4f512eaa5d905d">begin()</a> and <a class="el" href="classrt_1_1rt_soup.html#a69cbc7fb1506cf8797ddd0f91adc6239">end()</a> functions that return rtIteratorSoup&lt;T&gt; objects, also defined as rtSoup&lt;T&gt;::iterator. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classrt_1_1rt_iterator_soup.html">rtIteratorSoup</a>. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a555fe621b433bd314f70cb6640bd3443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">rt::rtAccelerationStructure::capability_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a443f4ecd765758f6a39f074b2fea69dd"></a>RT_IS_APPROXIMATE&#160;</td><td class="fielddoc">
<p>Capability flag to check whether the AS returns approximate distances to nearest elements. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a932066457619dc95342dd3a40c415b27"></a>RT_SUPPORTS_NEAREST_QUERIES&#160;</td><td class="fielddoc">
<p>Capability frag to check if the AS supports nearest element queries. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7bd15ccc008d70450d3d36e9f2316e79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::<a class="el" href="classrt_1_1rt_soup.html">rtSoup</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Initializes the metric to Euclidean distance in R3. </p>

</div>
</div>
<a class="anchor" id="a7eb46f751f84ef250d85c1416fd0f82b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::<a class="el" href="classrt_1_1rt_soup.html">rtSoup</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noThreadedExecution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the metric to Euclidean distance in R3 and provides the option to disable threaded execution.</p>
<p>This constructor is only useful for initializing a "baseline" sequential acceleration structure for benchmarking other AS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noThreadedExecution</td><td>specifies that no parallel execution should be attempted at any operation of the AS. Set to true only for comparing other stractures to the pure linear one (see unit tests). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2287c98cf3defb64577438f869b2277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::~<a class="el" href="classrt_1_1rt_soup.html">rtSoup</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual distructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abe17c49130779f2c4f5bcfffba88adce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::addData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a number num of elements of type T to the data structure.</p>
<p>The method can be called multiple times to inject more data to the acceleration structure. Each time the addData method is called, the ready flag must be set to false if the AS needs to be rebuilt (ususally it has to).</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, an error code with a brief explanation in the message field, otherwise. Typically, RT_INVALID_OPERATION must be returned if the structure is already initialized, and RT_INTERNAL_ERROR if something went wrong. No other return codes are applicable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_ptr</td><td>is a pointer to a preallocated array of elements of type T to be inserted in the AS. </td></tr>
    <tr><td class="paramname">num</td><td>defines the number of elements in the data_ptr array to read. Caution must be excercised to correctly specify the number of elements to read from the array, as there is no way to check its bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a3bafde672eea7c89daec7a9f61528e6f">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0feb2d7b404d54fa3a4f512eaa5d905d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_iterator_soup.html">rtIteratorSoup</a>&lt; T &gt; <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a forward input iterator to the internal acceleration structure data at the begin of the intenral collection implemented.</p>
<dl class="section return"><dt>Returns</dt><dd>the iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a30654f474a7643c355136e311d7e35d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs and / or finalizes internal data structures that hold the geometry data to be queried.</p>
<p>Derived classes must implement this method. The member function must set the ready member to true, if the initialization process was successful. </p><dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, an error code with a brief explanation in the message field, otherwise. Typically, RT_INVALID_OPERATION must be returned if the structure is already initialized, and RT_INTERNAL_ERROR if something went wrong. No other return codes are applicable. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae13d514293af0a332ac967f2c681223f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans up the data stored in the acceleration structure. </p>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#ab2b46dbb7cdf6c2edda6015f12c34416">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af62c83c06fbd18f6fae8f6a39c4b882c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::distanceToNearest </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance to the nearest element to the query input. All acceleration structures must override this method.</p>
<p>The method searches and returns the distance to the closest element to the query according to the distance metric provided in the AS. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>is the input query object of type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance to the nearest object in the AS, or FLT_MAX if the AS is empty or uninitialized. The return value is allowed to be a negative value, as particular acceleration structures may report negative (oriented) distances. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#af40b44b18aaa62c23af48a9578e8875e">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a69cbc7fb1506cf8797ddd0f91adc6239"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_iterator_soup.html">rtIteratorSoup</a>&lt; T &gt; <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a forward input iterator to the internal acceleration structure data at the end of the intenral collection implemented (out of range).</p>
<dl class="section return"><dt>Returns</dt><dd>an out-of-range iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a81f720a9c9bc2e542f326072f7619052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getBoundsMax </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bbmax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns in the parameter bbmax the three float coordinates of the maximum corner of the bounding box of the spatial data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbmax</td><td>is the pointer to a pre-allocated array that the three coordinates of the cbounding box corner are copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, or RT_INVALID_PARAMS if bbmax is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ab49b7304f1776de77305497f54514d2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getBoundsMin </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bbmin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns in the parameter bbmin the three float coordinates of the minimum corner of the bounding box of the spatial data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbmin</td><td>is the pointer to a pre-allocated array that the three coordinates of the cbounding box corner are copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, or RT_INVALID_PARAMS if bbmin is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a08e700204d3f7902cdfafe0aaf703a2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries if the acceleration structure provides a certain capability.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the AS has the specified capability. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e2a120b705163742db31245ac14417f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getErrorMargin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum error introduced by the spatial acceleration structure. This is zero for a non-approximate AS.</p>
<dl class="section return"><dt>Returns</dt><dd>0.0f if the AS is not approximate, otherwise the maximum (estimated) point-to-AS distance error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isApproximate. </dd></dl>

<p>Reimplemented in <a class="el" href="classrt_1_1rt_distance_field.html#a162639c87cd118f910b17713a8014742">rt::rtDistanceField&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af61b26f83e3b86e7f39dfb8c9ab40308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries whether the AS is ready for searching. Normally, this is true after calling <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">build()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the AS is initialized, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aac03d7959517dd6d3f026aeb33378780"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::multiDistanceToNearest </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance to the nearest element to the query input. It is the multiple input version of the <a class="el" href="classrt_1_1rt_soup.html#af62c83c06fbd18f6fae8f6a39c4b882c">distanceToNearest()</a> method.</p>
<p>The method searches and returns the distance of all query points to their respective closest element, according to the distance metric provided in the AS. The distance function provided may or may not use the entire set of coordinates. Whenever possible, use this function instead of the simple <a class="el" href="classrt_1_1rt_soup.html#af62c83c06fbd18f6fae8f6a39c4b882c">distanceToNearest()</a> method, as it favors efficient and parallel queries, depending on implementation. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to an array variable to contain the query results, if the operation is supported. The result array must be pre-allocated with sufficient space to hold num returned elements. </td></tr>
    <tr><td class="paramname">query</td><td>is an array of input elements of type T for which the closest elements are returned, if the operation is supported. </td></tr>
    <tr><td class="paramname">num</td><td>is the number of points to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a16683497078ff773425169dc208ed0d8">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7f541a73c15f626ea0c9a53c9b773726"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::multiNearest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest elements corresponding to the query points. It is the multiple input version of the <a class="el" href="classrt_1_1rt_soup.html#a8b29dadbc41ba928ba5afaf6d575013d">nearest()</a> method.</p>
<p>The method searches and returns the closest elements to the query array of points according to the distance metric provided in the AS. Whenever possible, use this function instead of the simple <a class="el" href="classrt_1_1rt_soup.html#a8b29dadbc41ba928ba5afaf6d575013d">nearest()</a> method, as it favors efficient and parallel queries, depending on implementation. If the method does not support the operation, the code retutned in the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is set to RT_INVALID _OPERATION. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to an array variable to contain the query results, if the operation is supported. The result array must be pre-allocated with sufficient space to hold num returned elements. </td></tr>
    <tr><td class="paramname">query</td><td>is an array of input elements of type T for which the closest elements are returned, if the operation is supported. </td></tr>
    <tr><td class="paramname">num</td><td>is the number of points to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a7a6bc8b2f860d4513bf5103fdaf2e3eb">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8b29dadbc41ba928ba5afaf6d575013d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_soup.html">rt::rtSoup</a>&lt; T &gt;::nearest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest element to the query input located in the data structure. This is an optional operation.</p>
<p>The method searches and returns the closest element to the query according to the distance metric provided in the AS. If the method does not support the operation, the code retutned in the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is set to RT_INVALID _OPERATION. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to a variable to contain the query result, if the operation is supported. </td></tr>
    <tr><td class="paramname">query</td><td>is the input query object of type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a09aab0d67005fa726a092d72d2a8124e">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad73b08f81da3844638af4bb847e4a66d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::setDistanceMetric </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float(const T &amp;, const T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets (overrides) the default distance metric defined for each one of the implementations of the <a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a> class prototype.</p>
<p>Initially, each implementation of an acceleration structure defines a default distance operator, typically related to Euclidean distance in 3D cartesian coordinates. The distance metric is used for comparing and locating objects within the AS. You can overide the metric in order to impose a user-defined function for this task. For example, you may want to include other attributes of the stored element in the metric, such as a normal directin or color. It is <b>invalid</b> to assign a distance metric to an already initialized structure.</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the metric was successfully set. If the data structure is already initialized (via the <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">build()</a>) function, the code field of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is set to RT_INVALID_OPERATION. No other code is applicable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td>is the function object that corresponds to the global function, functor or closure to execute for the distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62c0b9d3d46bd08ff021e683c99ccfa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of countable elements in the structure. Please note that this number may be not very descriptive for certain types of acceleration structure (e.g. distance fields).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of discrete elements in the AS. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a57cb179fba9d2636d71e57819af58c15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::capabilities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The binary mask of the AS capabilities. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/RT/<a class="el" href="soup_8h_source.html">soup.h</a></li>
<li>include/RT/<a class="el" href="soup_8hpp_source.html">soup.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
