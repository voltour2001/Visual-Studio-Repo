<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Registration Toolkit: rt::rtDistanceField&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rticon_inv.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Registration Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacert.html">rt</a></li><li class="navelem"><a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrt_1_1rt_distance_field-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rt::rtDistanceField&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="distancefield_8h_source.html">distancefield.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rt::rtDistanceField&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrt_1_1rt_distance_field.png" usemap="#rt::rtDistanceField_3C_20T_20_3E_map" alt=""/>
  <map id="rt::rtDistanceField_3C_20T_20_3E_map" name="rt::rtDistanceField&lt; T &gt;_map">
<area href="classrt_1_1rt_acceleration_structure.html" alt="rt::rtAccelerationStructure&lt; T &gt;" shape="rect" coords="0,0,189,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6f99fcb23e0831fe44e77154739dcf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6f99fcb23e0831fe44e77154739dcf6"></a>
typedef <a class="el" href="classrt_1_1rt_iterator_d_f.html">rtIteratorDF</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#ad6f99fcb23e0831fe44e77154739dcf6">iterator</a></td></tr>
<tr class="memdesc:ad6f99fcb23e0831fe44e77154739dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection iterator. Not used in this class. <br /></td></tr>
<tr class="separator:ad6f99fcb23e0831fe44e77154739dcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3fd7721bdacafd77a974409bebccc671"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a3fd7721bdacafd77a974409bebccc671">build</a> ()</td></tr>
<tr class="separator:a3fd7721bdacafd77a974409bebccc671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e6044df0b5e6efd95795c456dc8104"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a89e6044df0b5e6efd95795c456dc8104">addData</a> (T *data_ptr, unsigned long num)</td></tr>
<tr class="separator:a89e6044df0b5e6efd95795c456dc8104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e955f723215ddff3a6a87d98f7386ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a6e955f723215ddff3a6a87d98f7386ab">nearest</a> (T *result, const T &amp;query) const </td></tr>
<tr class="separator:a6e955f723215ddff3a6a87d98f7386ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a4453912ee8b44a8b2ded714e52657"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#ac9a4453912ee8b44a8b2ded714e52657">distanceToNearest</a> (const T &amp;query) const </td></tr>
<tr class="separator:ac9a4453912ee8b44a8b2ded714e52657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5a7891ab37a761f6dff28b7f03b577"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#adf5a7891ab37a761f6dff28b7f03b577">multiNearest</a> (T *result, T *query, unsigned int num) const </td></tr>
<tr class="separator:adf5a7891ab37a761f6dff28b7f03b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48b3c1f83720e30c879e4901e549658"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#aa48b3c1f83720e30c879e4901e549658">multiDistanceToNearest</a> (float *distance, T *query, unsigned long num) const </td></tr>
<tr class="separator:aa48b3c1f83720e30c879e4901e549658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af3ae4396f4549b6319e3f43e095131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_iterator_d_f.html">rtIteratorDF</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a0af3ae4396f4549b6319e3f43e095131">begin</a> () const </td></tr>
<tr class="separator:a0af3ae4396f4549b6319e3f43e095131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f59db52a916ccbe3d1cbe377215ee77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_iterator_d_f.html">rtIteratorDF</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a5f59db52a916ccbe3d1cbe377215ee77">end</a> () const </td></tr>
<tr class="separator:a5f59db52a916ccbe3d1cbe377215ee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5476243acfbe59152d64e4da09b2f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a3a5476243acfbe59152d64e4da09b2f2">clear</a> ()</td></tr>
<tr class="separator:a3a5476243acfbe59152d64e4da09b2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162639c87cd118f910b17713a8014742"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a162639c87cd118f910b17713a8014742">getErrorMargin</a> ()</td></tr>
<tr class="separator:a162639c87cd118f910b17713a8014742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ea530a358a71ea8dd85867036c937f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_distance_field.html#a52ea530a358a71ea8dd85867036c937f">rtDistanceField</a> (float granularity=0.0f, float max_distance=1.0f, int max_depth=3, int split_factor=4)</td></tr>
<tr class="separator:a52ea530a358a71ea8dd85867036c937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e700204d3f7902cdfafe0aaf703a2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a08e700204d3f7902cdfafe0aaf703a2e">getCapability</a> (<a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> cap) const </td></tr>
<tr class="separator:a08e700204d3f7902cdfafe0aaf703a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0b9d3d46bd08ff021e683c99ccfa8"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a62c0b9d3d46bd08ff021e683c99ccfa8">size</a> ()</td></tr>
<tr class="separator:a62c0b9d3d46bd08ff021e683c99ccfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b7304f1776de77305497f54514d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ab49b7304f1776de77305497f54514d2a">getBoundsMin</a> (float *bbmin)</td></tr>
<tr class="separator:ab49b7304f1776de77305497f54514d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f720a9c9bc2e542f326072f7619052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a81f720a9c9bc2e542f326072f7619052">getBoundsMax</a> (float *bbmax)</td></tr>
<tr class="separator:a81f720a9c9bc2e542f326072f7619052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73b08f81da3844638af4bb847e4a66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ad73b08f81da3844638af4bb847e4a66d">setDistanceMetric</a> (std::function&lt; float(const T &amp;, const T &amp;)&gt; <a class="el" href="classrt_1_1rt_acceleration_structure.html#ad5449aa3377282316745230f28b8258e">metric</a>)</td></tr>
<tr class="separator:ad73b08f81da3844638af4bb847e4a66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61b26f83e3b86e7f39dfb8c9ab40308"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#af61b26f83e3b86e7f39dfb8c9ab40308">isReady</a> ()</td></tr>
<tr class="separator:af61b26f83e3b86e7f39dfb8c9ab40308"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad5449aa3377282316745230f28b8258e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5449aa3377282316745230f28b8258e"></a>
std::function&lt; float(const T &amp;, const T &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#ad5449aa3377282316745230f28b8258e">metric</a></td></tr>
<tr class="memdesc:ad5449aa3377282316745230f28b8258e"><td class="mdescLeft">&#160;</td><td class="mdescRight">member to hold the distance metric used on the particular template data T. <br /></td></tr>
<tr class="separator:ad5449aa3377282316745230f28b8258e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e53f6c727f36e6c39e94b42d5d8cb9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a9e53f6c727f36e6c39e94b42d5d8cb9a">ready</a> = false</td></tr>
<tr class="memdesc:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the data structure is initialized and ready to query. <br /></td></tr>
<tr class="separator:a9e53f6c727f36e6c39e94b42d5d8cb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8aeacff50410161aab94447676c69f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e8aeacff50410161aab94447676c69f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a4e8aeacff50410161aab94447676c69f">_size</a></td></tr>
<tr class="memdesc:a4e8aeacff50410161aab94447676c69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal member holding the number of data elements (points);. <br /></td></tr>
<tr class="separator:a4e8aeacff50410161aab94447676c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cb179fba9d2636d71e57819af58c15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a57cb179fba9d2636d71e57819af58c15">capabilities</a></td></tr>
<tr class="memdesc:a57cb179fba9d2636d71e57819af58c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binary mask of the AS capabilities.  <a href="#a57cb179fba9d2636d71e57819af58c15">More...</a><br /></td></tr>
<tr class="separator:a57cb179fba9d2636d71e57819af58c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415cead4f56b55e5af0fab4299cdb90d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a415cead4f56b55e5af0fab4299cdb90d"></a>
Eigen::AlignedBox3f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a415cead4f56b55e5af0fab4299cdb90d">bbox</a></td></tr>
<tr class="memdesc:a415cead4f56b55e5af0fab4299cdb90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding box of the contained data. The box is oriented according to the local coordinate system (OBB). <br /></td></tr>
<tr class="separator:a415cead4f56b55e5af0fab4299cdb90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class rt::rtDistanceField&lt; T &gt;</h3>

<p>An implementation of a discretized truncated distance field.</p>
<p>A distance field is computed based on an input set of points and can be queried for arbitrary input locations in space to report the <em>distance</em> to the closest surface. A <em>distance</em> is measured with any metric supplied to the instance of the <a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a> (see <a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a> documentation). </p><div class="image">
<img src="df2.png" alt="df2.png"/>
<div class="caption">
Example of a distance field hierarchy (left) and the reprsented distance field up to the truncation limit (signed distances here). The visualization geometry was generated using the rt::dfVisualizer class.</div></div>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_example-_distance_field_8cpp-example.html#_a3">Example-DistanceField.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a555fe621b433bd314f70cb6640bd3443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">rt::rtAccelerationStructure::capability_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a443f4ecd765758f6a39f074b2fea69dd"></a>RT_IS_APPROXIMATE&#160;</td><td class="fielddoc">
<p>Capability flag to check whether the AS returns approximate distances to nearest elements. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a555fe621b433bd314f70cb6640bd3443a932066457619dc95342dd3a40c415b27"></a>RT_SUPPORTS_NEAREST_QUERIES&#160;</td><td class="fielddoc">
<p>Capability frag to check if the AS supports nearest element queries. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a52ea530a358a71ea8dd85867036c937f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::<a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a> </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>granularity</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_distance</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split_factor</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor with default parameters. Also acts as a default constructor.</p>
<p>In order to have a usable distance field, after constructing it, you must add data to it (i.e. the zero level set) with the <a class="el" href="classrt_1_1rt_distance_field.html#a89e6044df0b5e6efd95795c456dc8104">addData()</a> method and then construct the data structure by calculating distance values according to the specified granularity and up to the max_distance truncation limit, using the <a class="el" href="classrt_1_1rt_distance_field.html#a3fd7721bdacafd77a974409bebccc671">build()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">granularity</td><td>is the resolution setting of the DF. The smaller the granularity (in object units), the finer the detail captured by the distance field. However, finer detail also leads to higher memory requirements and longer build times. Balance this parameter carefully, according to your needs. Default value is 0.0f, which means that the <a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a> instance will attempt to estimate the required granularity automatically, from the spacing of the input data provided by the <a class="el" href="classrt_1_1rt_distance_field.html#a89e6044df0b5e6efd95795c456dc8104">addData()</a> method. </td></tr>
    <tr><td class="paramname">max_distance</td><td>is the extent of the field, or in other words, its truncation distance. The distance increases from zero at the boundary representation samples of the provided point cloud up to max_distance. After this limit, all distances queried return max_distance, i.e. a constant maximum value, hense the term "truncated distance field". </td></tr>
    <tr><td class="paramname">max_depth</td><td>is the DF hierarchy depth, with a default value of 3. The shalower the DF is, the faster the access, but more memory is consumed due to the flatter cell arrangement, where many dense cells are wasted. A deeper structure leads to better memory utilization, especially for detailed DFs. As a rule of thumb, dense, evenly distributed geometry and/or the use of large truncation distance benefits from a shalow DF, since the space will be eventually covered by non-maximal distance value cells. Convercely, sparse geometry with a moderate truncation distance, better use a deeper structure. The default depth of 3 is usually more than enough even for sparse point clouds, while maintaining a reasonable access time. </td></tr>
    <tr><td class="paramname">split_factor</td><td>is the cell subdivision factor per dimension. With a split_factor of 4 (the default value), each cell is subdivided into 4X4X4=64 finer cells in the hierarchical structure. If you use very shalow structures, you may want to increase the subdivision step to avoid creating too many zero level blocks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a89e6044df0b5e6efd95795c456dc8104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::addData </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a number num of elements of type T to the data structure.</p>
<p>The method can be called multiple times to inject more data to the acceleration structure. Each time the addData method is called, the ready flag must be set to false if the AS needs to be rebuilt (ususally it has to).</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, an error code with a brief explanation in the message field, otherwise. Typically, RT_INVALID_OPERATION must be returned if the structure is already initialized, and RT_INTERNAL_ERROR if something went wrong. No other return codes are applicable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_ptr</td><td>is a pointer to a preallocated array of elements of type T to be inserted in the AS. </td></tr>
    <tr><td class="paramname">num</td><td>defines the number of elements in the data_ptr array to read. Caution must be excercised to correctly specify the number of elements to read from the array, as there is no way to check its bounds. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a3bafde672eea7c89daec7a9f61528e6f">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0af3ae4396f4549b6319e3f43e095131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_iterator_d_f.html">rtIteratorDF</a>&lt; T &gt; <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a forward input iterator to the internal acceleration structure data at the begin of the internal collection implemented. Not implemented for <a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the iterator to the first element. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fd7721bdacafd77a974409bebccc671"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs and / or finalizes internal data structures that hold the geometry data to be queried.</p>
<p>Derived classes must implement this method. The member function must set the ready member to true, if the initialization process was successful. </p><dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, an error code with a brief explanation in the message field, otherwise. Typically, RT_INVALID_OPERATION must be returned if the structure is already initialized, and RT_INTERNAL_ERROR if something went wrong. No other return codes are applicable. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3a5476243acfbe59152d64e4da09b2f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans up the data stored in the acceleration structure. </p>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#ab2b46dbb7cdf6c2edda6015f12c34416">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a4453912ee8b44a8b2ded714e52657"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::distanceToNearest </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance to the nearest element to the query input. All acceleration structures must override this method.</p>
<p>The method searches and returns the distance to the closest element to the query according to the distance metric provided in the AS. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>is the input query object of type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the distance to the nearest object in the AS, or FLT_MAX if the AS is empty or uninitialized. The return value is allowed to be a negative value, as particular acceleration structures may report negative (oriented) distances. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#af40b44b18aaa62c23af48a9578e8875e">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5f59db52a916ccbe3d1cbe377215ee77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_iterator_d_f.html">rtIteratorDF</a>&lt; T &gt; <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a forward input iterator to the internal acceleration structure data at the end of the intenral collection implemented (out of range). Not implemented for <a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>an out-of-range iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a81f720a9c9bc2e542f326072f7619052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getBoundsMax </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bbmax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns in the parameter bbmax the three float coordinates of the maximum corner of the bounding box of the spatial data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbmax</td><td>is the pointer to a pre-allocated array that the three coordinates of the cbounding box corner are copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, or RT_INVALID_PARAMS if bbmax is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ab49b7304f1776de77305497f54514d2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getBoundsMin </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>bbmin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns in the parameter bbmin the three float coordinates of the minimum corner of the bounding box of the spatial data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbmin</td><td>is the pointer to a pre-allocated array that the three coordinates of the cbounding box corner are copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if everything proceeded normally, or RT_INVALID_PARAMS if bbmin is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a08e700204d3f7902cdfafe0aaf703a2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::getCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries if the acceleration structure provides a certain capability.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the AS has the specified capability. </dd></dl>

</div>
</div>
<a class="anchor" id="a162639c87cd118f910b17713a8014742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::getErrorMargin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum error introduced by the spatial acceleration structure. This is zero for a non-approximate AS.</p>
<dl class="section return"><dt>Returns</dt><dd>0.0f if the AS is not approximate, otherwise the maximum (estimated) point-to-AS distance error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>isApproximate. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a2e2a120b705163742db31245ac14417f">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af61b26f83e3b86e7f39dfb8c9ab40308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queries whether the AS is ready for searching. Normally, this is true after calling <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">build()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the AS is initialized, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa48b3c1f83720e30c879e4901e549658"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::multiDistanceToNearest </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance to the nearest element to the query input. It is the multiple input version of the <a class="el" href="classrt_1_1rt_distance_field.html#ac9a4453912ee8b44a8b2ded714e52657">distanceToNearest()</a> method.</p>
<p>The method searches and returns the distance of all query points to their respective closest element, according to the distance metric provided in the AS. The distance function provided may or may not use the entire set of coordinates. Whenever possible, use this function instead of the simple <a class="el" href="classrt_1_1rt_distance_field.html#ac9a4453912ee8b44a8b2ded714e52657">distanceToNearest()</a> method, as it favors efficient and parallel queries, depending on implementation. The distance function provided may or may not use the entire set of coordinates and features in the template type T.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to an array variable to contain the query results, if the operation is supported. The result array must be pre-allocated with sufficient space to hold num returned elements. </td></tr>
    <tr><td class="paramname">query</td><td>is an array of input elements of type T for which the closest elements are returned, if the operation is supported. </td></tr>
    <tr><td class="paramname">num</td><td>is the number of points to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the operation proceeded notmally and the referenced data in the acceleration structure contained at least one element. If the acceleration structure does not support the operation, the code returned is RT_INVALID_OPERATION. The method returns RT_FAILURE if the data structure is empty and RT_INVALID_OPERATION if it is uninitialized. The message member of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> specializes the reason of the invalid operation. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a16683497078ff773425169dc208ed0d8">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adf5a7891ab37a761f6dff28b7f03b577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::multiNearest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest elements corresponding to the query points. It is the multiple input version of the <a class="el" href="classrt_1_1rt_distance_field.html#a6e955f723215ddff3a6a87d98f7386ab">nearest()</a> method. This operation is <b>not</b> <b>supported</b> in <a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to an array variable to contain the query results, if the operation is supported. The result array must be pre-allocated with sufficient space to hold num returned elements. </td></tr>
    <tr><td class="paramname">query</td><td>is an array of input elements of type T for which the closest elements are returned, if the operation is supported. </td></tr>
    <tr><td class="paramname">num</td><td>is the number of points to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_INVALID_OPERATION. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a7a6bc8b2f860d4513bf5103fdaf2e3eb">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6e955f723215ddff3a6a87d98f7386ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_distance_field.html">rt::rtDistanceField</a>&lt; T &gt;::nearest </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest element to the query input located in the data structure. This operation is <b>not</b> <b>supported</b> in <a class="el" href="classrt_1_1rt_distance_field.html">rtDistanceField</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>is a pointer to a variable to contain the query result, if the operation is supported. </td></tr>
    <tr><td class="paramname">query</td><td>is the input query object of type T.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_INVALID_OPERATION. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_acceleration_structure.html#a09aab0d67005fa726a092d72d2a8124e">rt::rtAccelerationStructure&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad73b08f81da3844638af4bb847e4a66d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::setDistanceMetric </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; float(const T &amp;, const T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>metric</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets (overrides) the default distance metric defined for each one of the implementations of the <a class="el" href="classrt_1_1rt_acceleration_structure.html">rtAccelerationStructure</a> class prototype.</p>
<p>Initially, each implementation of an acceleration structure defines a default distance operator, typically related to Euclidean distance in 3D cartesian coordinates. The distance metric is used for comparing and locating objects within the AS. You can overide the metric in order to impose a user-defined function for this task. For example, you may want to include other attributes of the stored element in the metric, such as a normal directin or color. It is <b>invalid</b> to assign a distance metric to an already initialized structure.</p>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> object with the code set to RT_OK if the metric was successfully set. If the data structure is already initialized (via the <a class="el" href="classrt_1_1rt_acceleration_structure.html#a5cc36a7b6ce1ea4d8ac52a2312fbc254">build()</a>) function, the code field of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is set to RT_INVALID_OPERATION. No other code is applicable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">metric</td><td>is the function object that corresponds to the global function, functor or closure to execute for the distance metric. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62c0b9d3d46bd08ff021e683c99ccfa8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of countable elements in the structure. Please note that this number may be not very descriptive for certain types of acceleration structure (e.g. distance fields).</p>
<dl class="section return"><dt>Returns</dt><dd>the number of discrete elements in the AS. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a57cb179fba9d2636d71e57819af58c15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = Eigen::Vector3f&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> <a class="el" href="classrt_1_1rt_acceleration_structure.html">rt::rtAccelerationStructure</a>&lt; T &gt;::capabilities</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The binary mask of the AS capabilities. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classrt_1_1rt_acceleration_structure.html#a555fe621b433bd314f70cb6640bd3443">capability_t</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/RT/<a class="el" href="distancefield_8h_source.html">distancefield.h</a></li>
<li>include/RT/<a class="el" href="distancefield_8hpp_source.html">distancefield.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
