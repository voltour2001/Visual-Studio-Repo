<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Registration Toolkit: rt::rtPLYReader&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rticon_inv.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Registration Toolkit
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacert.html">rt</a></li><li class="navelem"><a class="el" href="classrt_1_1rt_p_l_y_reader.html">rtPLYReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrt_1_1rt_p_l_y_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">rt::rtPLYReader&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="io_8h_source.html">io.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rt::rtPLYReader&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrt_1_1rt_p_l_y_reader.png" usemap="#rt::rtPLYReader_3C_20T_20_3E_map" alt=""/>
  <map id="rt::rtPLYReader_3C_20T_20_3E_map" name="rt::rtPLYReader&lt; T &gt;_map">
<area href="classrt_1_1rt_reader.html" alt="rt::rtReader&lt; T &gt;" shape="rect" coords="0,56,137,80"/>
<area href="classrt_1_1rt_attribute_map.html" alt="rt::rtAttributeMap&lt; T &gt;" shape="rect" coords="0,0,137,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad484b570a96383024831e75802e8bbc5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#ad484b570a96383024831e75802e8bbc5">initialize</a> (std::istream *stream)</td></tr>
<tr class="separator:ad484b570a96383024831e75802e8bbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2143822fe05dc462eacfe9befeba67"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#a9a2143822fe05dc462eacfe9befeba67">readVertexData</a> (std::vector&lt; T &gt; *data, long num_vertices)</td></tr>
<tr class="separator:a9a2143822fe05dc462eacfe9befeba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7618ee437289152dfe1a4a1847f2691f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#a7618ee437289152dfe1a4a1847f2691f">readTriangleData</a> (std::vector&lt; long &gt; *indices, long num_triangles)</td></tr>
<tr class="separator:a7618ee437289152dfe1a4a1847f2691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc371fd72dfe927ce8391e8a850181"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#a5cbc371fd72dfe927ce8391e8a850181">readPointCloud</a> (std::istream *stream, std::vector&lt; T &gt; *data)</td></tr>
<tr class="separator:a5cbc371fd72dfe927ce8391e8a850181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501c515fddd188ba20c69be47e7ca183"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#a501c515fddd188ba20c69be47e7ca183">readMesh</a> (std::istream *stream, std::vector&lt; T &gt; *vertices, std::vector&lt; long &gt; *indices)</td></tr>
<tr class="separator:a501c515fddd188ba20c69be47e7ca183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920a6b9dfa07a3731c121d8e8f9baaa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#a920a6b9dfa07a3731c121d8e8f9baaa5">rtPLYReader</a> (int <a class="el" href="classrt_1_1rt_attribute_map.html#a34fa0a74383da0e38b63496e221ec2f1">attribs</a>=<a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24aae3e719603118107d7d0e5a7d123df3a2">RT_ATTRIB_POSITION</a>)</td></tr>
<tr class="separator:a920a6b9dfa07a3731c121d8e8f9baaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50b4afa27e46abe92125ba386861a6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_p_l_y_reader.html#a2e50b4afa27e46abe92125ba386861a6">~rtPLYReader</a> ()</td></tr>
<tr class="separator:a2e50b4afa27e46abe92125ba386861a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486bd221178a924071a882ff9db6054a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#a486bd221178a924071a882ff9db6054a">getNumVertices</a> ()</td></tr>
<tr class="separator:a486bd221178a924071a882ff9db6054a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e30395ba61aaf34891abb5867eb6f"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#a429e30395ba61aaf34891abb5867eb6f">getNumTriangles</a> ()</td></tr>
<tr class="separator:a429e30395ba61aaf34891abb5867eb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e47e2a358d19b2b8f52dbc9d39ad1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset</a> (int attrib, int <a class="el" href="classrt_1_1rt_attribute_map.html#ae5921f5cc265c14a09298b5416e4d6c3">offset</a>)</td></tr>
<tr class="separator:aa4e47e2a358d19b2b8f52dbc9d39ad1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbe15066b4584842f2cf34a45ceee70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a1bbe15066b4584842f2cf34a45ceee70">getAttributeOffset</a> (int attrib, int *<a class="el" href="classrt_1_1rt_attribute_map.html#ae5921f5cc265c14a09298b5416e4d6c3">offset</a>)</td></tr>
<tr class="separator:a1bbe15066b4584842f2cf34a45ceee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995b503fc21f3471cdbd04c2c18b928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrt_1_1rt_result.html">rtResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes</a> (int active_attribs)</td></tr>
<tr class="separator:a8995b503fc21f3471cdbd04c2c18b928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3699b59a318c93b11f3546cda476626f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a3699b59a318c93b11f3546cda476626f">getActiveAttributes</a> ()</td></tr>
<tr class="separator:a3699b59a318c93b11f3546cda476626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6e614575f49a07443e76d6c467e75691"><td class="memItemLeft" align="right" valign="top">std::istream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#a6e614575f49a07443e76d6c467e75691">p_stream</a></td></tr>
<tr class="memdesc:a6e614575f49a07443e76d6c467e75691"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to the currently used input stream. This is required for partial data reads used in the out-of-core data structure implementations.  <a href="#a6e614575f49a07443e76d6c467e75691">More...</a><br /></td></tr>
<tr class="separator:a6e614575f49a07443e76d6c467e75691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefaee12dcb53e4bb0eb1ca200469076"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#abefaee12dcb53e4bb0eb1ca200469076">cur_vertex</a></td></tr>
<tr class="memdesc:abefaee12dcb53e4bb0eb1ca200469076"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current, zero-based vertex entry to be extracted. If cur_vertex equals total_vertices, all vertices have been already read.  <a href="#abefaee12dcb53e4bb0eb1ca200469076">More...</a><br /></td></tr>
<tr class="separator:abefaee12dcb53e4bb0eb1ca200469076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f549cdf327699a633aade4bb988b63f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#a9f549cdf327699a633aade4bb988b63f">total_vertices</a></td></tr>
<tr class="memdesc:a9f549cdf327699a633aade4bb988b63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of vertices reported in the file.  <a href="#a9f549cdf327699a633aade4bb988b63f">More...</a><br /></td></tr>
<tr class="separator:a9f549cdf327699a633aade4bb988b63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7d5278561b8a3d789074d1b4e843d4"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#aaa7d5278561b8a3d789074d1b4e843d4">cur_triangle</a></td></tr>
<tr class="memdesc:aaa7d5278561b8a3d789074d1b4e843d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current, zero-based triangle entry to be extracted. If cur_triangle equals total_triangles, all triangles have been already read.  <a href="#aaa7d5278561b8a3d789074d1b4e843d4">More...</a><br /></td></tr>
<tr class="separator:aaa7d5278561b8a3d789074d1b4e843d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b633dc4bf28fd5d85adb4e402f4e91"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_reader.html#ac2b633dc4bf28fd5d85adb4e402f4e91">total_triangles</a></td></tr>
<tr class="memdesc:ac2b633dc4bf28fd5d85adb4e402f4e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of triangles reported in the file.  <a href="#ac2b633dc4bf28fd5d85adb4e402f4e91">More...</a><br /></td></tr>
<tr class="separator:ac2b633dc4bf28fd5d85adb4e402f4e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fa0a74383da0e38b63496e221ec2f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#a34fa0a74383da0e38b63496e221ec2f1">attribs</a></td></tr>
<tr class="memdesc:a34fa0a74383da0e38b63496e221ec2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mask of the active vertex attributes to export. If no other attribute is specified, the attribs mask equals RT_ATTRIB_POSITION.  <a href="#a34fa0a74383da0e38b63496e221ec2f1">More...</a><br /></td></tr>
<tr class="separator:a34fa0a74383da0e38b63496e221ec2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5921f5cc265c14a09298b5416e4d6c3"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrt_1_1rt_attribute_map.html#ae5921f5cc265c14a09298b5416e4d6c3">offset</a></td></tr>
<tr class="memdesc:ae5921f5cc265c14a09298b5416e4d6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the offset with respect to the base pointer to a structure T (as the map entry value) of the attribute specified in the key argument.  <a href="#ae5921f5cc265c14a09298b5416e4d6c3">More...</a><br /></td></tr>
<tr class="separator:ae5921f5cc265c14a09298b5416e4d6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class rt::rtPLYReader&lt; T &gt;</h3>

<dl><dt><b>Examples: </b></dt><dd><a class="el" href="_example-_distance_field_8cpp-example.html#_a0">Example-DistanceField.cpp</a>, and <a class="el" href="_example-_p_l_y_reader_8cpp-example.html#_a2">Example-PLYReader.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a920a6b9dfa07a3731c121d8e8f9baaa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::<a class="el" href="classrt_1_1rt_p_l_y_reader.html">rtPLYReader</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribs</em> = <code><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24aae3e719603118107d7d0e5a7d123df3a2">RT_ATTRIB_POSITION</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e50b4afa27e46abe92125ba386861a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::~<a class="el" href="classrt_1_1rt_p_l_y_reader.html">rtPLYReader</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3699b59a318c93b11f3546cda476626f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::getActiveAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the mask of enabled attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>the attribute mask.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1bbe15066b4584842f2cf34a45ceee70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::getAttributeOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the designated offset in the vertex data structure of the named attribute attrib, in bytes.</p>
<p>All attributes are considered float numbers. Vertex attributes are 3 consecutive float numbers (x,y,z), colour attributes are a float triplet representing the 3 colour component (r,g,b), the normal attribute expects 3 consecutive floats (the normal vector coordinates) and finally, the texture parameters are two floats corresponding to the two (u,v or s,t) texture parameters on the surface of the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td>should be one of RT_ATTRIB_POSITION, RT_ATTRIB_NORMAL, RT_ATTRIB_COLOR or RT_ATTRIB_TEXCOORD and signifies the offset definition for vertex, normal, color or texture coordinate attributes respectively. </td></tr>
    <tr><td class="paramname">offset</td><td>is the returned distance in bytes from the beginning of the data structure T that the corresponding attrib values begin at. If the attrib parameter is valid, the offset parameter is filled with the corresponding value. If the attribute identifier is out of range or no offset has been assigned to it, no value is written to offset and an error code is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure, whose code is RT_OK if the attribute was valid and its offset was set. Ifthe attribute did not match the enabled attributes, the return code is set to RT_INVALID_PARAMS. If the attribute offset was not set, an RT_FAILURE code is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a429e30395ba61aaf34891abb5867eb6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::getNumTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of triangles discovered in the formatted file.</p>
<dl class="section return"><dt>Returns</dt><dd>the counted triangles after calling the <a class="el" href="classrt_1_1rt_reader.html#a1d121d21f9b5baba08862be9923f0ab3">initialize()</a> member or -1 if the <a class="el" href="classrt_1_1rt_reader.html#a1d121d21f9b5baba08862be9923f0ab3">initialize()</a> has not been called yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a486bd221178a924071a882ff9db6054a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices discovered in the formatted file.</p>
<dl class="section return"><dt>Returns</dt><dd>the counted vertices after calling the <a class="el" href="classrt_1_1rt_reader.html#a1d121d21f9b5baba08862be9923f0ab3">initialize()</a> member or -1 if the <a class="el" href="classrt_1_1rt_reader.html#a1d121d21f9b5baba08862be9923f0ab3">initialize()</a> has not been called yet. </dd></dl>

</div>
</div>
<a class="anchor" id="ad484b570a96383024831e75802e8bbc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract the header information from the input stream of a formatted geometric representation (e.g. a file) and initialize internal reader data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>is an open stream to begin reading the format's header data from. The stream is not closed and is maintained internally for successive data reads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure with the code field set to RT_OK if the header information was successfully read and processed. The code is RT_FAILURE if the header could not be processed, RT_INVALID_OPERATION if the initialize method is not implemented and RT_INVALID_PARAMS if the pointer to a stream passed is NULL. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_reader.html#a1d121d21f9b5baba08862be9923f0ab3">rt::rtReader&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a501c515fddd188ba20c69be47e7ca183"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::readMesh </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; long &gt; *&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads all the geometric data as a mesh from a stream.</p>
<p>The point data of type T can be an arbitrary structure. The only requirement is that the individual vertex attribute coordinates are consecutive float numbers. The exact offset of each attribute tupple is provided by the settAttributeOffset() method. The triangular structure of the mesh is retrned as a vector of triangle vertex indices (zero-based) in the indices parameter. If the indices parameter is NULL, no indexing is assumed, in which case the input vertices are replicated to form triplets that correspond to the input triangles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>is the already initialized input stream to from which to read the data. </td></tr>
    <tr><td class="paramname">data</td><td>is a buffer of type T vertex structures. </td></tr>
    <tr><td class="paramname">indices</td><td>is a buffer of zero-based indices to the vertex buffer points. If it is equal to 0, input points are considered in triplets and num_vertices/3 triangles are formed in the output file. In this case, the num_triangles parameter is ignorred. </td></tr>
    <tr><td class="paramname">num_triangles</td><td>is used to determine the number of index triangles in the mesh in the case the indexing is provided explicitly through the parameter indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure containing the exit code of the member function. On successful write, a result with RT_OK is returned. If the method is not supported, an RT_INVALID_OPERATION is returned. Last, if the file cannot be opened for writing, the return code of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is RT_FAILURE. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_reader.html#ad2ae44be10409913f72b4ded9fc73274">rt::rtReader&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5cbc371fd72dfe927ce8391e8a850181"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::readPointCloud </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the entire point cloud from an open input stream.</p>
<p>The point data of type T can be an arbitrary structure. The only requirement is that the individual vertex attribute coordinates are consecutive float numbers. The exact offset of each attribute tupple is provided by the settAttributeOffset() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>is the already initialized input stream to file name of the point cloud to read. </td></tr>
    <tr><td class="paramname">data</td><td>is a vector to append the vertex data of type T to. Note: the data vector is not cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure containing the exit code of the member function. On successful read, a result with RT_OK is returned. If the method is not supported, an RT_INVALID_OPERATION is returned. Last, if the file cannot be opened for reading or a read error occured, the return code of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is RT_FAILURE. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_reader.html#ad931e993abf2b3ee4538d83026c782f5">rt::rtReader&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7618ee437289152dfe1a4a1847f2691f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::readTriangleData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; long &gt; *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_triangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads some triangle data from an open input stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>is a vector to append the requested indices to the vertex buffer to. Note: the indices vector is not cleared. </td></tr>
    <tr><td class="paramname">num_triangles</td><td>is the maximum number of triangles to extract, so at most 3 X number of indices are copied to the indices vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure containing the exit code of the member function. On successful read, a result with RT_OK is returned. If the method is not supported, an RT_INVALID_OPERATION is returned. Last, if the stream cannot be opened for reading or a read error occured, the return code of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is RT_FAILURE. Note that if the requested number of triangles to read is larger than the available index triplets in the stream, an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> with code RT_END_OF_DATA is returned to indicate the end of available triangle data, however this is not an error condition. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_reader.html#a3445c7f6ff5dd4f300026393078679b9">rt::rtReader&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9a2143822fe05dc462eacfe9befeba67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_p_l_y_reader.html">rt::rtPLYReader</a>&lt; T &gt;::readVertexData </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads some vertex data from an open input stream.</p>
<p>The point data of type T can be an arbitrary structure. The only requirement is that the individual vertex attribute coordinates are consecutive float numbers. The exact offset of each attribute tupple is provided by the settAttributeOffset() method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>is a vector to append the vertex data of type T to. Note: the data vector is not cleared. </td></tr>
    <tr><td class="paramname">num_vertices</td><td>is the maximum number of vertices to try to extract from the formated data of the stream, so at most num_vertices vertex attribute structures will be appended to data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure containing the exit code of the member function. On successful read, a result with RT_OK is returned. If the method is not supported, an RT_INVALID_OPERATION is returned. Last, if the stream cannot be opened for reading or a read error occured, the return code of the <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> is RT_FAILURE. Note that if the requested number of vertices to read is larger than the available vertices in the stream, an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> with code RT_END_OF_DATA is returned to indicate the end of vertex data, however this is not an error condition. </dd></dl>

<p>Reimplemented from <a class="el" href="classrt_1_1rt_reader.html#a33ea2c9456ceadf1b3f7c63b7f30c5d3">rt::rtReader&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8995b503fc21f3471cdbd04c2c18b928"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::setActiveAttributes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>active_attribs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the mask of attributes to enable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active_attribs</td><td>is a binary mask of enabled attributes formed by the OR of the desired attribute_t flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure, whose code is RT_OK if the mask was correct or RT_INVALID_PARAMS, otherwise.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#aa4e47e2a358d19b2b8f52dbc9d39ad1f">setAttributeOffset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa4e47e2a358d19b2b8f52dbc9d39ad1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrt_1_1rt_result.html">rtResult</a> <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::setAttributeOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies the offset in the vertex data structure of the named attribute attrib, in bytes.</p>
<p>All attributes are considered float numbers. Vertex attributes are 3 consecutive float numbers (x,y,z), colour attributes are a float triplet representing the 3 colour component (r,g,b), the normal attribute expects 3 consecutive floats (the normal vector coordinates) and finally, the texture parameters are two floats corresponding to the two (u,v or s,t) texture parameters on the surface of the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrib</td><td>should be one of RT_ATTRIB_POSITION, RT_ATTRIB_NORMAL, RT_ATTRIB_COLOR or RT_ATTRIB_TEXCOORD and signifies the offset definition for vertex, normal, color or texture coordinate attributes respectively. </td></tr>
    <tr><td class="paramname">offset</td><td>is the distance in bytes from the beginning of the data structure T that the corresponding attrib values begin at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="classrt_1_1rt_result.html" title="rtResult is a helper class to accommodate the result code of an operation along with an (optional) re...">rtResult</a> structure, whose code is RT_OK if the offset for the specific attribute was successfully set or RT_INVALID_PARAMS if the attribute for which the offset was passed is not active or the offset is too large.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacert.html#a08de0f0856333ef60cf490c6af3bb24a">attribute_t</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#a8995b503fc21f3471cdbd04c2c18b928">setActiveAttributes</a> </dd>
<dd>
<a class="el" href="classrt_1_1rt_attribute_map.html#a1bbe15066b4584842f2cf34a45ceee70">getAttributeOffset</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a34fa0a74383da0e38b63496e221ec2f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::attribs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mask of the active vertex attributes to export. If no other attribute is specified, the attribs mask equals RT_ATTRIB_POSITION. </p>

</div>
</div>
<a class="anchor" id="aaa7d5278561b8a3d789074d1b4e843d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::cur_triangle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current, zero-based triangle entry to be extracted. If cur_triangle equals total_triangles, all triangles have been already read. </p>

</div>
</div>
<a class="anchor" id="abefaee12dcb53e4bb0eb1ca200469076"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::cur_vertex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current, zero-based vertex entry to be extracted. If cur_vertex equals total_vertices, all vertices have been already read. </p>

</div>
</div>
<a class="anchor" id="ae5921f5cc265c14a09298b5416e4d6c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, int&gt; <a class="el" href="classrt_1_1rt_attribute_map.html">rt::rtAttributeMap</a>&lt; T &gt;::offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the offset with respect to the base pointer to a structure T (as the map entry value) of the attribute specified in the key argument. </p>

</div>
</div>
<a class="anchor" id="a6e614575f49a07443e76d6c467e75691"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream* <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::p_stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The pointer to the currently used input stream. This is required for partial data reads used in the out-of-core data structure implementations. </p>

</div>
</div>
<a class="anchor" id="ac2b633dc4bf28fd5d85adb4e402f4e91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::total_triangles</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of triangles reported in the file. </p>

</div>
</div>
<a class="anchor" id="a9f549cdf327699a633aade4bb988b63f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classrt_1_1rt_reader.html">rt::rtReader</a>&lt; T &gt;::total_vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of vertices reported in the file. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/RT/<a class="el" href="io_8h_source.html">io.h</a></li>
<li>include/RT/<a class="el" href="io__ply_8hpp_source.html">io_ply.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
